### 全行注解，方便理解~

🌇 点赞 👍 收藏 ⭐留言 📝 一键三连 ~关注Nick，从你我做起！

### 方法一：中心扩散法

**核心思路：每次遍历一个字符的时候，就以该字符为回文中心，向字符两边扩散判断是否对称！**
值得注意的就是，要考虑到奇数、偶数个字符对称判断情况不一样！

### 执行效率图

![image.png](https://pic.leetcode-cn.com/1641953493-EMYLZb-image.png)

### 代码

* java

```java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            /**
             * len1 是判读奇数个字符 对称情况 ： abcba  所以传入坐标要传left = 2,right = 2 len = 5
             * len2 是判断偶数个字符 对称情况 ： abccba 所以传入坐标要传left = 2,right = 3 len = 6
             * 然后选取较大的一个最为返回答案！
             */
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                /**
                 * len 回文字符串长度
                 * len / 2 回文字符串一半的长度
                 * 所以 计算起始坐标就是用当前坐标 减去 一半的长度 i -+ len / 2
                 * 但是如果是偶数个回文字符，计算开始坐标时就要额外加 1（这也是多次测试后得出结论）
                 */
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    public int expandAroundCenter(String s, int left, int right) {
        /**
         * 从中心扩散，判断该字符两边是否对称回文！
         */
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            --left;
            ++right;
        }
        return right - left - 1;
    }
}
```

