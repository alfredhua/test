### 解题思路

该题可以使用动态规划解决。
考虑这样一个事实，如果一个字符串本身是回文串，那么把这个字符串掐头去尾之后依然是回文串，也即如果`s`的位置`i`到`j`（包含`i`,`j`）的子串是回文串，那么`s`的位置`i+1`到`j-1`的子串也必然是回文串。例如，`axyzyxa`是回文串，那么掐头去尾以后的字符串`xyzyx`也是回文串。

于是我们可以使用动态规划来解决该问题，我们用`dp[i][j]`表示`s`的位置`i`到`j`的子串是否是回文串，如果该子串是回文串，那么`dp[i][j]=true`，否则`dp[i][j]=false`。根据上一段的分析，显然有`dp[i][j]`为真的条件是`dp[i+1][j-1]`也为真，且`s[i]==s[j]`。再考虑边界条件，当`i==j`时，`dp[i][j]`显然为真，当`i>j`时，`dp[i][j]`显然为假。此外还要注意子串长度为`2`的情况，在这种情况下，只需要保证`s[i]==s[j]`，`dp[i][j]`即为真。

根据以上讨论，我们可以得到算法：
1.计算字符串长度`m`，初始化`dp[i][j](0≤i<m,0≤j<m)`为假，最长回文子串长度`maxLen`为`0`，最长回文子串`ans`为`""`；
2.从`i=m-1`，`j=m-1`开始遍历更新`dp[i][j]`，`i`不断递减，`j`不断递增，同时当`dp[i][j]`为真时更新最长回文子串长度及最长回文子串。
填表完成时的`ans`就是最长回文子串。

### 代码

* cpp

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int m = s.size();//字符串长度
        vector<vector<bool>> dp(m,vector<bool>(m,false));//dp[i][j]表示s中位置i到j的子串是否是回文串
        int maxLen = 0;//最长的回文子串长度
        string ans;//答案
        for(int i = m-1; i >= 0; i--){//从m-1, m-1开始依次填表dp
            for(int j = i; j < m; j++){
                if(i == j) dp[i][j] = true;//若i==j，则dp[i][j]=false;
                else{//若i，j不相等
                    if(j-i == 1) dp[i][j] = s[i]==s[j];//若位置i到j的子串长度为2，则dp[i][j]为真的条件是s[i]==s[j]
                    else dp[i][j] = s[i]==s[j] && dp[i+1][j-1];//否则dp[i][j]为真的条件是dp[i+1][j-1]为真且s[i]==s[j]
                } 
                if(dp[i][j] && maxLen<j-i+1){//如果s中位置i到j的子串是回文串
                   maxLen = j-i+1;//则更新最长回文串长度
                   ans = s.substr(i,j-i+1); //以及最长回文串
                } 
            }
        }
        return ans;//返回答案
    }
};
```

### 复杂度分析

**时间复杂度：** `O(m²)`。m为字符串长度，主要是填表的时间消耗。
**空间复杂度：** `O(m²)`。主要是存储各子串是否为回文串的空间消耗。
![魔法女孩.gif](https://pic.leetcode-cn.com/1640524809-TbtVLn-%E9%AD%94%E6%B3%95%E5%A5%B3%E5%AD%A9.gif)
